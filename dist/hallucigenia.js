#!/usr/bin/env node
import{Separator as F,checkbox as ee,confirm as te,editor as oe,input as U,password as re,select as $}from"@inquirer/prompts";import a from"chalk";import W from"clear";import se from"figlet";import R from"ora";import Q from"axios";import{homedir as K}from"os";import j from"path";var P=j.join(K(),".hallucigenia"),O=".conf",c=j.join(P,"repositories"),x="https://api.bitbucket.org/2.0",D={frames:["\u280B","\u2819","\u2839","\u2838","\u283C","\u2834","\u2826","\u2827","\u2807","\u280F"],interval:100};function H(t){return Q.create({baseURL:x,headers:{Accept:"application/json",Authorization:`Bearer ${t}`}})}async function G(t){return(await H(t.repository_access_token).get(`/repositories/${t.repository_workspace_name}/${t.repository_name}`)).data}async function A(t){let e=H(t.repository_access_token),r=`/repositories/${t.repository_workspace_name}/${t.repository_name}/refs/branches?pagelen=100&page=1`,s=[];for(;r;){let i=(await e.get(r.replace(x,""))).data;r=i.next,s.push(...i.values)}return s}import L from"fs";var I=class{#e;#t;constructor(){this.#e="home",this.#t=null,this.#o(),this.#r()}GetMenu(){return this.#e}GetTargetRepositoryId(){if(!this.#t)throw new Error("No target repository id");return this.#t}SetMenu(e,o){this.#e=e,this.#t=o||null}#o(){L.mkdirSync(P,{recursive:!0})}#r(){L.mkdirSync(c,{recursive:!0})}};import q from"fs";import Z from"path";import{exec as z,spawn as Y}from"child_process";import{randomUUID as X}from"crypto";import u from"fs";import h from"path";import{z as f}from"zod";var M=f.object({branch_name:f.string(),hash:f.string().optional()}),N=f.object({repository_id:f.string(),repository_name:f.string(),repository_access_token:f.string(),repository_workspace_name:f.string(),branches:f.array(M),observed_branches:f.array(M),remote_connection_status:f.enum(["ok","ko"])});import J from"os";function E(t){return new Promise(e=>setTimeout(e,t))}function b(){return J.platform()==="win32"?".bat":".sh"}var k=class{#e;constructor(e){this.#e=e,this.GetRepositoryConf(),this.#r()}static AttachRepository(e,o){let r=X(),s=N.safeParse({repository_id:r,...o,observed_branches:[],branches:[],remote_connection_status:"ok"});if(!s.success)throw new Error("Invalid repository .conf");return u.mkdirSync(h.join(c,e),{recursive:!0}),u.writeFileSync(h.join(c,e,O),JSON.stringify(s.data),{encoding:"utf-8"}),r}DettachRepository(){u.rmSync(h.join(c,this.#e),{recursive:!0,force:!0})}GetRepositoryId(){return this.GetRepositoryConf().repository_id}GetRepositorySlug(){return this.#e}GetRepositoryConf(){let e=this.#t(this.#e);if(!e.success)throw new Error(`Failed to create the Repository class to "${this.#e}"`);return e.data}UpdateRepositoryConf(e){let o={...this.GetRepositoryConf(),...e};u.writeFileSync(this.#o(this.#e),JSON.stringify(o))}GetRepositoryScriptList(){return u.readdirSync(h.join(c,this.#e,"scripts"),{withFileTypes:!0}).filter(o=>o.isFile()&&o.name.endsWith(b())).map(o=>o.name.split(".").at(0))}GetRepositoryScriptContent(e){try{return u.readFileSync(h.join(c,this.#e,"scripts",`${e}${b()}`),{encoding:"utf8"})}catch{return}}CreateRepositoryScript(e,o){u.writeFileSync(h.join(c,this.#e,"scripts",`${e}${b()}`),o,{encoding:"utf8"})}DeleteRepositoryScript(e){u.rmSync(h.join(c,this.#e,"scripts",`${e}${b()}`),{recursive:!0,force:!0})}UpdateRepositoryScript(e,o){u.writeFileSync(h.join(c,this.#e,"scripts",`${e}${b()}`),o,{encoding:"utf8"})}RunRepositoryScript(e,o){try{let r=new Date().getTime(),s=`${e}${b()}`,i=`${e}-${r}.txt`,n=h.join(c,this.#e,"scripts"),y=h.join(c,this.#e,"logs"),l=u.createWriteStream(h.join(y,i)),d=Y(s,{cwd:n,env:{...process.env,UPDATED_BRANCH_PATH:h.join(c,this.#e,"branches",o)},shell:!0,stdio:"pipe"});return d.stdout.on("data",m=>{m&&m.toString&&l.write(m.toString())}),d.stderr.on("data",m=>{m&&m.toString&&l.write(m.toString())}),d.on("close",m=>{l.write(`script exited with code ${m||"unknown"}`),l.end()}),!0}catch{return!1}}async CacheBranch(e){let o=this.GetRepositoryConf(),r=h.join(c,this.#e,"branches",e);this.UncacheBranch(e);let s=`git clone -b "${e}" "https://x-token-auth:${o.repository_access_token}@bitbucket.org/${o.repository_workspace_name}/${o.repository_name}.git" "${r}"`,i=z(s),n=await new Promise(y=>{i.on("exit",(l,d)=>{l!==0&&y(!1),y(!0)})});return n||this.UncacheBranch(e),n}UncacheBranch(e){let o=h.join(c,this.#e,"branches",e);u.rmSync(o,{recursive:!0,force:!0})}#t(e){let o=this.#o(e),r;try{let s=u.readFileSync(o,{encoding:"utf-8"}).toString();r=JSON.parse(s)}catch{r={}}return N.safeParse(r)}#o(e){return h.join(c,e,O)}#r(){u.mkdirSync(h.join(c,this.#e,"branches"),{recursive:!0}),u.mkdirSync(h.join(c,this.#e,"scripts"),{recursive:!0}),u.mkdirSync(h.join(c,this.#e,"logs"),{recursive:!0})}};var T=class{#e=[];constructor(){this.SyncRepos()}GetRepos(){return this.#e}GetRepo(e){let o=this.#e.find(r=>r.GetRepositoryId()===e);if(!o)throw new Error("Repository not found");return o}SyncRepos(){this.#e=this.#t()}UncacheUnobservedBranches(){for(let e of this.#e){let o=q.readdirSync(Z.join(c,e.GetRepositorySlug(),"branches"),{withFileTypes:!0}).filter(r=>r.isDirectory());for(let r of o)e.GetRepositoryConf().observed_branches.find(s=>s.branch_name===r.name)||e.UncacheBranch(r.name)}}#t(){let e=[];return q.readdirSync(c,{withFileTypes:!0}).filter(r=>r.isDirectory()).forEach(r=>{try{let s=new k(r.name);e.push(s)}catch{}}),e}};var B={bitbucket:{repository_name:async(t,e)=>{for(let o of e){let r=o.repository_workspace_name===t.repository_workspace_name,s=o.repository_name===t.repository_name;if(r&&s)return"There is a repository already using this repository name on the same workspace, you are probably duplicating it"}return!0},access_token:async t=>{try{return await G({repository_access_token:t.repository_access_token,repository_workspace_name:t.repository_workspace_name,repository_name:t.repository_name}),!0}catch{return"Could not establish connection with the remote repository"}},slug:async(t,e)=>{for(let o of e)if(o===t)return"There is already a repository using this slug";return!0}},github:{test:void 0}};function v(t,e){if(!B[t])throw new Error("Requested context not available");if(!B[t][e])throw new Error("Requested validator not available on context");return B[t][e]}var p=new I,_=new T;async function ne(){_.SyncRepos(),await V()}async function V(){W(),console.log(se.textSync("Hallucigenia")),console.log(`
	found ~> ${a.bgGreen(` ${_.GetRepos().length} repositories `)}

`),await ie[p.GetMenu()](),_.SyncRepos(),await V()}var ie={home:async()=>{console.log(a.bgCyanBright(` HOME 
`));let t=await $({message:"",loop:!1,choices:[{name:"Watcher",value:"watch mode",description:"Watch branches for changes"},{name:"Repositories",value:"repositories",description:"List & add repositories"},{name:a.red("Quit"),value:"quit",description:"Quit the app & stop monitoring repositories"}]});p.SetMenu(t,null)},"watch mode":async()=>{console.log(a.bgCyanBright(` WATCHING BRANCHES 
`));let t=R("watching branches for changes...(ctrl+c to stop)").start(),e=_.GetRepos().filter(i=>i.GetRepositoryConf().remote_connection_status==="ok"),o=await new Promise(i=>{let n=[];Promise.allSettled(e.map(y=>A({repository_access_token:y.GetRepositoryConf().repository_access_token,repository_name:y.GetRepositoryConf().repository_name,repository_workspace_name:y.GetRepositoryConf().repository_workspace_name}))).then(y=>{for(let l=0;l<e.length;l++){let d=e.at(l),m=y.at(l);if(m.status==="rejected")return;for(let w of d.GetRepositoryConf().observed_branches){let g=m.value.find(S=>S.name===w.branch_name);g&&g.target.hash!==w.hash&&n.push({repo_id:d.GetRepositoryConf().repository_id,branch_name:w.branch_name,branch_hash:g.target.hash})}}i(n)})});t.info(`detected changes on ${o.length} branches

`);for(let i of o){let n=_.GetRepo(i.repo_id),y=R(`cloning branch "${i.branch_name}" of "${n.GetRepositoryConf().repository_name}"`).start();if(await n.CacheBranch(i.branch_name)){n.UpdateRepositoryConf({observed_branches:[...n.GetRepositoryConf().observed_branches.filter(C=>C.branch_name!==i.branch_name),{branch_name:i.branch_name,hash:i.branch_hash}]}),y.succeed(`branch "${i.branch_name}" of "${n.GetRepositoryConf().repository_name}" cloned successfully`);let d=n.GetRepositoryScriptList(),m=d.find(C=>C===i.branch_name),w=d.find(C=>C===n.GetRepositoryConf().repository_name),g,S;switch(!0){case typeof m<"u":g=R("running branch update script...").start(),S=n.RunRepositoryScript(m,i.branch_name);break;case typeof w<"u":g=R("running repository update script...").start(),S=n.RunRepositoryScript(w,i.branch_name);break;default:break}g&&S&&(S?g.succeed("script invoked successfully"):g.fail("failed to invoke script"))}else y.fail(`failed to clone branch "${i.branch_name}" of "${n.GetRepositoryConf().repository_name}"`)}let r=1e3*60*1,s=R({text:a.bgBlackBright(`
[ on cooldown ]`),spinner:{interval:r/7.2,frames:["\u25B1\u25B1\u25B1\u25B1\u25B1\u25B1\u25B1","\u25B0\u25B1\u25B1\u25B1\u25B1\u25B1\u25B1","\u25B0\u25B0\u25B1\u25B1\u25B1\u25B1\u25B1","\u25B0\u25B0\u25B0\u25B1\u25B1\u25B1\u25B1","\u25B0\u25B0\u25B0\u25B0\u25B1\u25B1\u25B1","\u25B0\u25B0\u25B0\u25B0\u25B0\u25B1\u25B1","\u25B0\u25B0\u25B0\u25B0\u25B0\u25B0\u25B1","\u25B0\u25B0\u25B0\u25B0\u25B0\u25B0\u25B0"]}}).start();await E(r),s.stop()},repositories:async()=>{console.log(a.bgCyanBright(` REPOSITORIES 
`));let t=await $({message:"",loop:!1,choices:[{name:a.yellow("< go back"),value:"home"},{name:a.green("+ add repo"),value:"add repository",description:"Configure new repository to be monitored"},{name:"! check connections",value:"check repositories connection"},new F("\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500"),..._.GetRepos().map(e=>{let o=e.GetRepositoryConf();return{name:`${e.GetRepositorySlug()} ${o.remote_connection_status==="ok"?a.green("(connected)"):a.red("(no connection)")}`,value:`id_${o.repository_id}`}})]});t.startsWith("id_")?p.SetMenu("repository options",t.replace("id_","")):p.SetMenu(t,null)},"add repository":async()=>{console.log(a.bgCyanBright(` ADD REMOTE REPOSITORY CONNECTION 
`));let t=await U({message:`${a.blue("workspace")} name or UUID:`}),e=await U({message:`${a.blue("repository")} name or UUID:`,validate:s=>v("bitbucket","repository_name")({repository_workspace_name:t,repository_name:s},_.GetRepos().map(n=>n.GetRepositoryConf()))}),o=await re({message:`repository ${a.yellow("access token")}:`,mask:"*",validate:s=>v("bitbucket","access_token")({repository_access_token:s,repository_workspace_name:t,repository_name:e}),theme:{spinner:D}}),r=await U({message:"repository alias: ",default:e,validate:s=>v("bitbucket","slug")(s,_.GetRepos().map(n=>n.GetRepositorySlug()))});k.AttachRepository(r,{repository_access_token:o,repository_name:e,repository_workspace_name:t}),p.SetMenu("repositories",null)},"repository options":async()=>{let t=_.GetRepo(p.GetTargetRepositoryId());console.log(a.bgCyanBright(` DETAILS ~> [ ${t.GetRepositorySlug()} ] 
`));let e=await $({message:"",loop:!1,choices:[{name:a.yellow("< go back"),value:"repositories"},{name:"! sync branch list",value:"sync repository branches"},new F("\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500"),{name:`Observable branches [${t.GetRepositoryConf().observed_branches.length}/${t.GetRepositoryConf().branches.length}]`,value:"repository branches",description:"List & select branches from repository to be observed"},{name:`Side Effects [${t.GetRepositoryConf().observed_branches.filter(o=>t.GetRepositoryScriptList().includes(o.branch_name)).length}/${t.GetRepositoryConf().observed_branches.length}]`,value:"repository side effects",description:"instructions to run when branches get updated"},{name:"Delete repository",value:"delete repository"}]});p.SetMenu(e,p.GetTargetRepositoryId())},"delete repository":async()=>{let t=_.GetRepo(p.GetTargetRepositoryId());if(console.log(a.bgCyanBright(` DELETE ~> [ ${t.GetRepositorySlug()} ] 
`)),await te({message:"Are you sure you want to delete this repository and all files related to it?",default:!1})){t.DettachRepository(),p.SetMenu("repositories",null);return}p.SetMenu("repository options",p.GetTargetRepositoryId())},"repository branches":async()=>{let t=_.GetRepo(p.GetTargetRepositoryId()),{branches:e,observed_branches:o}=t.GetRepositoryConf();console.log(a.bgCyanBright(` OBSERVABLE BRANCHES ~> [ ${t.GetRepositorySlug()} ] 
`));let r=e.filter(n=>!!o.find(y=>y.branch_name===n.branch_name)),s=e.filter(n=>!o.find(y=>y.branch_name===n.branch_name)),i=await ee({message:"select branches to observe",choices:[...r.map(n=>({name:n.branch_name,value:n.branch_name,checked:!0})),...s.map(n=>({name:n.branch_name,value:n.branch_name,checked:!1}))],loop:!1});t.UpdateRepositoryConf({observed_branches:i.map(n=>({branch_name:n,hash:void 0}))}),_.UncacheUnobservedBranches(),p.SetMenu("repository options",p.GetTargetRepositoryId())},"check repositories connection":async()=>{console.log(a.bgCyanBright(` CHECKING CONNECTION TO REMOTE REPOSITORIES 
`));let t=R({text:`checking connection to ${_.GetRepos().length} repositories`}).start();for(let e of _.GetRepos()){let o=e.GetRepositoryConf();try{await G({repository_access_token:o.repository_access_token,repository_workspace_name:o.repository_workspace_name,repository_name:o.repository_name}),e.UpdateRepositoryConf({remote_connection_status:"ok"})}catch{e.UpdateRepositoryConf({remote_connection_status:"ko"})}}t.succeed(),await E(2e3),p.SetMenu("repositories",null)},"sync repository branches":async()=>{let t=_.GetRepo(p.GetTargetRepositoryId()),e=t.GetRepositoryConf();console.log(a.bgCyanBright(` UPDATING BRANCH LIST ~> [ ${t.GetRepositorySlug()} ] 
`));let o=R({text:`updating local branch list from remote "${e.repository_name}"`}).start();try{let r=await A({repository_access_token:e.repository_access_token,repository_workspace_name:e.repository_workspace_name,repository_name:e.repository_name});t.UpdateRepositoryConf({branches:r.map(s=>({branch_name:s.name,hash:s.target.hash}))})}catch{t.UpdateRepositoryConf({branches:[]})}o.succeed(),await E(2e3),p.SetMenu("repository options",p.GetTargetRepositoryId())},"repository side effects":async()=>{let t=_.GetRepo(p.GetTargetRepositoryId()),e=t.GetRepositoryConf(),o=t.GetRepositoryScriptList();console.log(a.bgCyanBright(` SIDE EFFECTS ~> [ ${t.GetRepositorySlug()} ] 
`));let r=await $({message:"",loop:!1,choices:[{name:a.yellow("< go back"),value:"repository options"},{name:`default script [${o.includes(e.repository_name)?a.green("set"):a.red("not set")}]`,value:"default script",description:"This script will run for updated branches that don't have an specific one"},new F("\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500"),...e.observed_branches.map(s=>({name:`branch "${s.branch_name}" script [${o.includes(s.branch_name)?a.green("set"):a.red("not set")}]`,value:`branch_${s.branch_name}`}))]});if(r.startsWith("branch_")||r==="default script"){let s=r.replace("branch_","").replace("default script",e.repository_name),i=t.GetRepositoryScriptContent(s),n=await oe({message:`
1- The script will be saved and run according to the CURRENT system executing the CLI.
2- After writing the script, just save and close your editor.
3- During the script execution the environment variable "UPDATED_BRANCH_PATH" will be available to easy access to the branch source path.
4- To "delete" the script just leave the editor blank.
5- The script will be run from the app folder it's stored, if you want to make changes to other paths make sure to "cd" to them and/or use absolute paths.
`,waitForUseInput:!0,postfix:b(),default:i||""});switch(!0){case(n.trim().length===0&&typeof i=="string"):t.DeleteRepositoryScript(s);break;case(n.trim().length!==0&&typeof i=="string"):t.UpdateRepositoryScript(s,n);break;case(n.trim().length!==0&&typeof i>"u"):t.CreateRepositoryScript(s,n);break;default:break}return}p.SetMenu(r,p.GetTargetRepositoryId())},quit:()=>{W(),process.exit()}};ne();
